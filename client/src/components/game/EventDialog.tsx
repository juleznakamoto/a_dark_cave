import React, { useState, useEffect, useRef } from "react";
import { useGameStore } from "@/game/state";
import { LogEntry } from "@/game/rules/events";
import { getTotalKnowledge } from "@/game/rules/effectsCalculation";
import { calculateKnowledgeTimeBonus, isKnowledgeBonusMaxed } from "@/game/rules/effectsStats";
import { eventChoiceCostTooltip } from "@/game/rules/tooltips";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { TooltipWrapper } from "@/components/game/TooltipWrapper";
import CubeDialog from "./CubeDialog";

interface EventDialogProps {
  isOpen: boolean;
  onClose: () => void;
  event: LogEntry | null;
}

// Stat icon mapping
const statIcons: Record<string, { icon: string; color: string }> = {
  luck: { icon: '☆', color: 'text-green-300/80' },
  strength: { icon: '⬡', color: 'text-red-300/80' },
  knowledge: { icon: '✧', color: 'text-blue-300/80' },
  madness: { icon: '✺', color: 'text-violet-300/80' },
};

export default function EventDialog({
  isOpen,
  onClose,
  event,
}: EventDialogProps) {
  const { applyEventChoice } = useGameStore();
  const gameState = useGameStore();
  const hasScriptorium = gameState.buildings.scriptorium > 0;

  const [timeRemaining, setTimeRemaining] = useState<number | null>(null);
  const [totalTime, setTotalTime] = useState<number>(0);
  const startTimeRef = useRef<number>(0);
  const fallbackExecutedRef = useRef(false);

  // Derive eventChoices directly from event prop instead of using state
  const eventChoices = typeof event?.choices === 'function'
    ? event.choices(gameState)
    : event?.choices || [];

  // Reset purchased items when dialog opens
  useEffect(() => {
    if (isOpen) {
      // No longer need to reset purchased items as merchant dialog is removed
    }
  }, [isOpen, event?.id]);

  // Initialize timer for timed choices
  useEffect(() => {
    if (!event || !event.isTimedChoice || !isOpen) {
      setTimeRemaining(null);
      setTotalTime(0);
      fallbackExecutedRef.current = false;
      return;
    }

    const knowledge = getTotalKnowledge(gameState);
    const timeBonus = calculateKnowledgeTimeBonus(knowledge);
    const decisionTime = (event.baseDecisionTime || 15) + timeBonus;

    setTotalTime(decisionTime);
    setTimeRemaining(decisionTime);
    startTimeRef.current = Date.now();
    fallbackExecutedRef.current = false;

    const interval = setInterval(() => {
      if (fallbackExecutedRef.current) {
        return;
      }

      const elapsed = (Date.now() - startTimeRef.current) / 1000;
      const remaining = Math.max(0, decisionTime - elapsed);

      setTimeRemaining(remaining);

      if (remaining <= 0 && !fallbackExecutedRef.current) {
        fallbackExecutedRef.current = true;
        clearInterval(interval);

        const eventId = event.id.split("-")[0];

        if (event.fallbackChoice) {
          // Use defined fallback choice
          applyEventChoice(event.fallbackChoice.id, eventId);
        } else if (eventChoices.length > 0) {
          // No fallback defined, choose randomly from available choices
          const randomChoice =
            eventChoices[Math.floor(Math.random() * eventChoices.length)];
          applyEventChoice(randomChoice.id, eventId);
        }

        onClose();
      }
    }, 100);

    return () => {
      clearInterval(interval);
      fallbackExecutedRef.current = false;
    };
  }, [event?.id, event?.isTimedChoice, event?.baseDecisionTime, isOpen, eventChoices]); // Added eventChoices dependency

  // Merchant choices are now generated by the event definition itself
  // No need for useEffect since eventChoices is derived directly from event.choices

  // Add timer logic for timed events
  // This is already handled in the useEffect above, no changes needed here.

  if (!event || !eventChoices.length) return null;

  const handleChoice = (choiceId: string) => {
    if (fallbackExecutedRef.current) {
      return;
    }

    const eventId = event!.id.split("-")[0];
    const isMerchantEvent = event?.id.includes("merchant");
    const isSayGoodbye = choiceId === "say_goodbye";
    const isAcknowledge = choiceId === "acknowledge";

    // For "acknowledge" buttons (log messages), just close the dialog
    if (isAcknowledge) {
      fallbackExecutedRef.current = true;
      onClose();
      return;
    }

    // For merchant "say goodbye", just close the dialog without processing
    if (isMerchantEvent && isSayGoodbye) {
      fallbackExecutedRef.current = true;
      onClose();
      return;
    }

    // For merchant trades (not goodbye), mark item as purchased but don't close dialog
    // This logic is now handled by the specific merchant event's choice effects.
    // The general handling below will apply.

    // Handle special actions for mysterious note event
    if (eventId === "mysteriousNote") {
      const choice = eventChoices.find((c) => c.id === choiceId);
      if (choice) {
        const result = choice.effect(gameState);

        // Handle shop opening
        if ((result as any)._openShop) {
          fallbackExecutedRef.current = true;
          applyEventChoice(choiceId, eventId);
          onClose();
          gameState.setShopDialogOpen(true);
          return;
        }

        // Handle donation page opening
        if ((result as any)._openDonation) {
          fallbackExecutedRef.current = true;
          applyEventChoice(choiceId, eventId);
          onClose();
          window.open("https://buymeacoffee.com/julianbudev", "_blank");
          return;
        }
      }
    }

    // For non-merchant events, process normally
    fallbackExecutedRef.current = true;
    applyEventChoice(choiceId, eventId);
    onClose();
  };

  const progress =
    event.isTimedChoice && timeRemaining !== null && totalTime > 0
      ? ((totalTime - timeRemaining) / totalTime) * 100
      : 0;

  const isCubeEvent = event?.id?.startsWith("cube");

  return (
    <>
      {isCubeEvent ? (
        <CubeDialog
          isOpen={isOpen}
          event={event}
          onChoice={handleChoice}
          fallbackExecutedRef={fallbackExecutedRef}
        />
      ) : (
        <Dialog
          open={isOpen}
          onOpenChange={(open) => {
            // Empty handler - we don't want automatic closing
            // All closing should be handled explicitly through handleChoice
          }}
        >
          <DialogContent className="w-[95vw] sm:max-w-md [&>button]:hidden">
            <DialogHeader>
              <div className="flex items-center justify-between gap-2">
                <DialogTitle className="text-lg font-semibold">
                  {event.title || "Event"}
                </DialogTitle>
                <div className="flex gap-2 items-center flex-shrink-0">
                  {hasScriptorium && event.isTimedChoice && getTotalKnowledge(gameState) > 0 && (
                    <TooltipWrapper
                      tooltip={
                        <div className="text-xs whitespace-nowrap">
                          +{calculateKnowledgeTimeBonus(getTotalKnowledge(gameState))}s Decision Time due to Knowledge{isKnowledgeBonusMaxed(getTotalKnowledge(gameState)) ? " (max)" : ""}
                        </div>
                      }
                      tooltipId="event-time-bonus"
                    >
                      <span className="text-blue-300/80 cursor-pointer hover:text-blue-300 transition-colors inline-block text-xl">
                        ✧
                      </span>
                    </TooltipWrapper>
                  )}
                  {hasScriptorium && event.relevant_stats && event.relevant_stats.length > 0 && (
                    <div className="flex gap-1">
                      {event.relevant_stats.map((stat) => {
                        const statInfo = statIcons[stat.toLowerCase()];
                        if (!statInfo) return null;
                        return (
                          <span
                            key={stat}
                            className={`text-xs ${statInfo.color}`}
                            title={stat}
                          >
                            {statInfo.icon}
                          </span>
                        );
                      })}
                    </div>
                  )}
                </div>
              </div>
              <DialogDescription className="text-sm text-gray-400 mt-2">
                {event.message}
              </DialogDescription>
            </DialogHeader>

            <div className="grid grid-cols-2 gap-3 mt-4">
              {eventChoices.map((choice) => {
                const cost = choice.cost;
                let isDisabled = (timeRemaining !== null && timeRemaining <= 0) || fallbackExecutedRef.current;

                // Evaluate cost if it's a function
                const costText = typeof cost === 'function' ? cost(gameState) : cost;

                // Check if player can afford the cost
                let canAfford = true;
                if (costText) {
                  const resourceKeys = Object.keys(gameState.resources) as Array<keyof typeof gameState.resources>;
                  for (const resourceKey of resourceKeys) {
                    if (costText.includes(resourceKey)) {
                      const match = costText.match(new RegExp(`(\\d+)\\s*${resourceKey}`));
                      if (match) {
                        const cost = parseInt(match[1]);
                        if (gameState.resources[resourceKey] < cost) {
                          canAfford = false;
                          isDisabled = true;
                          break;
                        }
                      }
                    }
                  }
                }

                // Evaluate label if it's a function
                const labelText = typeof choice.label === 'function'
                  ? choice.label(gameState)
                  : choice.label;

                // Calculate success percentage if available and book_of_war is owned
                let successPercentage: string | null = null;
                if (choice.success_chance !== undefined && gameState.books?.book_of_war) {
                  const successChance = typeof choice.success_chance === 'function'
                    ? choice.success_chance(gameState)
                    : choice.success_chance;
                  successPercentage = `${Math.round(successChance * 100)}%`;
                }

                const buttonContent = (
                  <Button
                    onClick={() => handleChoice(choice.id)}
                    variant="outline"
                    className="w-full text-left justify-between"
                    disabled={isDisabled}
                    button_id={`event-choice-${choice.id}`}
                  >
                    <span>{labelText}</span>
                    <div className="flex gap-1 items-center ml-2">
                      {successPercentage && (
                        <span className="text-xs text-muted-foreground">
                          {successPercentage}
                        </span>
                      )}
                      {hasScriptorium && choice.relevant_stats && choice.relevant_stats.length > 0 && (
                        <div className="flex gap-1">
                          {choice.relevant_stats.map((stat) => {
                            const statInfo = statIcons[stat.toLowerCase()];
                            if (!statInfo) return null;
                            return (
                              <span
                                key={stat}
                                className={`text-xs ${statInfo.color}`}
                                title={stat}
                              >
                                {statInfo.icon}
                              </span>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  </Button>
                );

                return costText ? (
                  <TooltipWrapper
                    key={choice.id}
                    className="relative block w-full"
                    tooltip={
                      <div className="text-xs whitespace-nowrap">
                        {eventChoiceCostTooltip.getContent(costText, gameState)}
                      </div>
                    }
                    tooltipId={choice.id}
                    disabled={isDisabled}
                  >
                    {buttonContent}
                  </TooltipWrapper>
                ) : (
                  <div key={choice.id} className="w-full">
                    {buttonContent}
                  </div>
                );
              })}
            </div>

            {/* Timer bar for timed events */}
            {event.isTimedChoice && timeRemaining !== null && (
              <div className="mt-1 space-y-1">
                <div className="flex justify-between text-sm text-muted-foreground">
                </div>
                <Progress value={progress} className="h-2 timer-progress" />
              </div>
            )}
          </DialogContent>
        </Dialog>
      )}
    </>
  );
}