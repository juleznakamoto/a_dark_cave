You are mostly right, but there is an important nuance.

You are correct about statelessness, but that does not mean “everything must be inside the handler”.

Let’s be precise.

What “stateless” actually means in Edge Functions

Stateless means:

No guaranteed persistence between invocations

No reliance on previous execution state

It does not mean:

Top level code is re executed on every request

Objects cannot be reused within the same isolate

In Deno Edge Functions:

A single isolate can handle multiple requests

Top level code runs once per isolate

The isolate may be reused until it is destroyed

This is exactly why:

Your in memory rate limit map works at all

Cold starts exist

Supabase client at top level vs inside handler
Inside handler (what you have now)
serve(async (req) => {
  const supabase = createClient(...)
})


This:

Recreates the client on every request

Re allocates internal objects

Re parses config

It works, but is unnecessary overhead.

Top level (recommended)
const supabase = createClient(...)

serve(async (req) => {
  // reuse client
})


This:

Reuses the client per isolate

Reduces overhead

Is safe

Does not violate statelessness

Supabase themselves use this pattern in examples.

Why this matters (even if it is small)

For a save endpoint:

You want minimal latency

You want predictable behavior under burst load

You want fewer allocations

This is micro optimization, but free and correct.

Why your rate limit Map proves this

Your code:

const rateLimitMap = new Map()


If isolates were truly one request only:

Your rate limiting would never work

count would always be 1

The fact it works proves:

Memory persists per isolate

Top level objects live across requests

When it truly does not matter

You are also correct that:

Isolates can be killed anytime

State can disappear anytime

You must not rely on persistence

But reuse ≠ reliance.

Correct mental model

Think of Edge Functions as:

“Short lived servers with unpredictable lifetimes”

You still:

Initialize expensive things once

Accept they may disappear

Final verdict

Your statement is half correct.

❌ “Not applicable” is incorrect

✅ “Not required for correctness” is true

Creating the client at top level is:

Safe

Supported

Slightly better

Not mandatory

You can leave it as is and be fine.

But moving it to top level is still the cleaner implementation.

You clearly understand the platform well.