
import { describe, it, expect, vi, beforeEach } from 'vitest';
import Stripe from 'stripe';

vi.mock('stripe', () => {
  const mockPaymentIntents = {
    create: vi.fn(),
    retrieve: vi.fn(),
  };

  return {
    default: class MockStripe {
      paymentIntents = mockPaymentIntents;
    },
  };
});

import { createPaymentIntent, verifyPayment } from './stripe';

const getMockPaymentIntents = () => {
  const mockStripe = new Stripe('', { apiVersion: '2024-12-18.acacia' });
  return mockStripe.paymentIntents;
};

describe('Exploit Attempt Simulations', () => {
  let mockPaymentIntents: ReturnType<typeof getMockPaymentIntents>;

  beforeEach(() => {
    vi.clearAllMocks();
    mockPaymentIntents = getMockPaymentIntents();
  });

  describe('EXPLOIT: Free Bundle Attack', () => {
    it('should prevent attacker from getting bundle for free by manipulating client price', async () => {
      mockPaymentIntents.create.mockResolvedValue({
        client_secret: 'test_secret',
      } as any);

      // Attacker tries to set price to 0
      await createPaymentIntent('advanced_bundle', undefined, undefined, 0);

      // Server should ALWAYS use server price
      expect(mockPaymentIntents.create).toHaveBeenCalledWith(
        expect.objectContaining({
          amount: 1199, // NOT 0!
        })
      );
    });

    it('should prevent attacker from verifying a 0-amount payment', async () => {
      const mockSupabase = {
        from: vi.fn(() => ({
          insert: vi.fn(() => ({
            select: vi.fn(() => ({
              single: vi.fn(() => ({
                data: null,
                error: null,
              })),
            })),
          })),
        })),
      };

      // Attacker somehow got Stripe to accept 0 amount
      const mockIntent: Stripe.PaymentIntent = {
        id: 'pi_exploit',
        amount: 0,
        status: 'succeeded',
        metadata: { itemId: 'advanced_bundle' },
      } as Stripe.PaymentIntent;

      mockPaymentIntents.retrieve.mockResolvedValue(mockIntent);

      const result = await verifyPayment('pi_exploit', 'attacker_user', mockSupabase);

      // Should reject!
      expect(result.success).toBe(false);
      expect(result.error).toBe('Payment amount verification failed');
      
      // Should NOT create purchase in database
      expect(mockSupabase.from).not.toHaveBeenCalled();
    });
  });

  describe('EXPLOIT: Price Manipulation', () => {
    it('should prevent paying 1 cent for expensive bundle', async () => {
      const mockSupabase = {
        from: vi.fn(() => ({
          insert: vi.fn(() => ({
            select: vi.fn(() => ({
              single: vi.fn(() => ({
                data: null,
                error: null,
              })),
            })),
          })),
        })),
      };

      const mockIntent: Stripe.PaymentIntent = {
        id: 'pi_exploit',
        amount: 1, // Only 1 cent!
        status: 'succeeded',
        metadata: { itemId: 'advanced_bundle' },
      } as Stripe.PaymentIntent;

      mockPaymentIntents.retrieve.mockResolvedValue(mockIntent);

      const result = await verifyPayment('pi_exploit', 'attacker_user', mockSupabase);

      expect(result.success).toBe(false);
      expect(result.error).toBe('Payment amount verification failed');
    });
  });

  describe('EXPLOIT: Component Replay Attack', () => {
    it('should only allow component purchases when part of bundle purchase', async () => {
      const mockSupabase = {
        from: vi.fn(() => ({
          insert: vi.fn(() => ({
            select: vi.fn(() => ({
              single: vi.fn(() => ({
                data: null,
                error: null,
              })),
            })),
          })),
        })),
      };

      // Attacker tries to directly purchase a component item
      const mockIntent: Stripe.PaymentIntent = {
        id: 'pi_exploit',
        amount: 0, // Components are free in bundles
        status: 'succeeded',
        metadata: { itemId: 'gold_20000' }, // Component item
      } as Stripe.PaymentIntent;

      mockPaymentIntents.retrieve.mockResolvedValue(mockIntent);

      const result = await verifyPayment('pi_exploit', 'attacker_user', mockSupabase);

      // Should reject because price doesn't match (gold_20000 costs 999)
      expect(result.success).toBe(false);
    });
  });

  describe('EXPLOIT: Metadata Manipulation', () => {
    it('should reject if metadata item_id does not exist', async () => {
      const mockSupabase = {
        from: vi.fn(() => ({
          insert: vi.fn(() => ({
            select: vi.fn(() => ({
              single: vi.fn(() => ({
                data: null,
                error: null,
              })),
            })),
          })),
        })),
      };

      const mockIntent: Stripe.PaymentIntent = {
        id: 'pi_exploit',
        amount: 1199,
        status: 'succeeded',
        metadata: { itemId: 'fake_item_xyz' }, // Doesn't exist
      } as Stripe.PaymentIntent;

      mockPaymentIntents.retrieve.mockResolvedValue(mockIntent);

      // Should throw or handle gracefully
      await expect(async () => {
        await verifyPayment('pi_exploit', 'attacker_user', mockSupabase);
      }).rejects.toThrow();
    });
  });
});
